/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17821 2009-11-11 09:00:00Z dts12 $
 */

#include "psychMIB.hh"

#include <list>

/* Boost threading. */
#include <boost/thread/shared_mutex.hpp>

/* redirect namespace pollution */
#define U64 __netsnmp_U64

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* revert Net-snmp namespace pollution */
#undef U64
#define __netsnmp_LOG_EMERG	0
#define __netsnmp_LOG_ALERT	1
#define __netsnmp_LOG_CRIT	2
#define __netsnmp_LOG_ERR	3
#define __netsnmp_LOG_WARNING	4
#define __netsnmp_LOG_NOTICE	5
#define __netsnmp_LOG_INFO	6
#define __netsnmp_LOG_DEBUG	7
static_assert (__netsnmp_LOG_EMERG   == LOG_EMERG,   "LOG_EMERGE mismatch");
static_assert (__netsnmp_LOG_ALERT   == LOG_ALERT,   "LOG_ALERT mismatch");
static_assert (__netsnmp_LOG_CRIT    == LOG_CRIT,    "LOG_CRIT mismatch");
static_assert (__netsnmp_LOG_ERR     == LOG_ERR,     "LOG_ERR mismatch");
static_assert (__netsnmp_LOG_WARNING == LOG_WARNING, "LOG_WARNING mismatch");
static_assert (__netsnmp_LOG_NOTICE  == LOG_NOTICE,  "LOG_NOTICE mismatch");
static_assert (__netsnmp_LOG_INFO    == LOG_INFO,    "LOG_INFO mismatch");
static_assert (__netsnmp_LOG_DEBUG   == LOG_DEBUG,   "LOG_DEBUG mismatch");
#undef LOG_EMERG
#undef LOG_ALERT
#undef LOG_CRIT
#undef LOG_ERR
#undef LOG_WARNING
#undef LOG_NOTICE
#undef LOG_INFO
#undef LOG_DEBUG

#include "chromium/logging.hh"
#include "psych.hh"
#include "provider.hh"
#include "session.hh"

namespace psych {

/* http://en.wikipedia.org/wiki/Unix_epoch */
static const boost::posix_time::ptime kUnixEpoch (boost::gregorian::date (1970, 1, 1));

static int initialize_table_psychPluginTable(void);
static Netsnmp_Node_Handler psychPluginTable_handler;
static Netsnmp_First_Data_Point psychPluginTable_get_first_data_point;
static Netsnmp_Next_Data_Point psychPluginTable_get_next_data_point;
static Netsnmp_Free_Loop_Context psychPluginTable_free_loop_context;

static int initialize_table_psychPluginPerformanceTable(void);
static Netsnmp_Node_Handler psychPluginPerformanceTable_handler;
static Netsnmp_First_Data_Point psychPluginPerformanceTable_get_first_data_point;
static Netsnmp_Next_Data_Point psychPluginPerformanceTable_get_next_data_point;
static Netsnmp_Free_Loop_Context psychPluginPerformanceTable_free_loop_context;

static int initialize_table_psychSessionTable(void);
static Netsnmp_Node_Handler psychSessionTable_handler;
static Netsnmp_First_Data_Point psychSessionTable_get_first_data_point;
static Netsnmp_Next_Data_Point psychSessionTable_get_next_data_point;
static Netsnmp_Free_Loop_Context psychSessionTable_free_loop_context;

static int initialize_table_psychSessionPerformanceTable(void);
static Netsnmp_Node_Handler psychSessionPerformanceTable_handler;
static Netsnmp_First_Data_Point psychSessionPerformanceTable_get_first_data_point;
static Netsnmp_Next_Data_Point psychSessionPerformanceTable_get_next_data_point;
static Netsnmp_Free_Loop_Context psychSessionPerformanceTable_free_loop_context;

/* Context during a SNMP query, lock on global list of psych_t objects and iterator.
 */
class snmp_context_t
{
public:
	snmp_context_t (boost::shared_mutex& lock_, std::list<psych::psych_t*>& list_) :
		lock (lock_),
		psych_list (list_),
		psych_it (psych_list.begin())
	{
	}

/* Plugins are owned by AE, locking is required. */
	boost::shared_lock<boost::shared_mutex> lock;
	std::list<psych::psych_t*>& psych_list;
	std::list<psych::psych_t*>::iterator psych_it;
	std::vector<std::unique_ptr<psych::session_t>>::iterator session_it;

/* SNMP agent is not-reentrant, ignore locking. */
	static std::list<std::shared_ptr<snmp_context_t>> global_list;
};

std::list<std::shared_ptr<snmp_context_t>> snmp_context_t::global_list;

/* Initializes the psychMIB module.
 */
bool
init_psychMIB(void)
{
/* here we initialize all the tables we're planning on supporting */
	if (MIB_REGISTERED_OK != initialize_table_psychPluginTable()) {
		LOG(ERROR) << "psychPluginTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_psychPluginPerformanceTable()) {
		LOG(ERROR) << "psychPluginPerformanceTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_psychSessionTable()) {
		LOG(ERROR) << "psychSessionTable registration: see SNMP log for further details.";
		return false;
	}
	if (MIB_REGISTERED_OK != initialize_table_psychSessionPerformanceTable()) {
		LOG(ERROR) << "psychSessionPerformanceTable registration: see SNMP log for further details.";
		return false;
	}
	return true;
}

/* Initialize the psychPluginTable table by defining its contents and how it's structured.
 */
static
int
initialize_table_psychPluginTable(void)
{
	DLOG(INFO) << "initialize_table_psychPluginTable()";

	static const oid psychPluginTable_oid[] = {1,3,6,1,4,1,67,2,1,2};
	const size_t psychPluginTable_oid_len = OID_LENGTH (psychPluginTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"psychPluginTable",	psychPluginTable_handler,
		psychPluginTable_oid,	psychPluginTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: psychPluginId */
					  ASN_UNSIGNED,  /* index: psychPluginInstance */
					  0);
	table_info->min_column = COLUMN_PSYCHPLUGINWINDOWSREGISTRYKEY;
	table_info->max_column = COLUMN_PSYCHPLUGINVENDORNAME;
    
	iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= psychPluginTable_get_first_data_point;
	iinfo->get_next_data_point	= psychPluginTable_get_next_data_point;
	iinfo->free_loop_context_at_end	= psychPluginTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
static 
netsnmp_variable_list*
psychPluginTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychPluginTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (psych::psych_t::global_list_lock_, psych::psych_t::global_list_));
	if (!(bool)context || context->psych_list.empty()) {
		DLOG(INFO) << "No instances";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return psychPluginTable_get_next_data_point (my_loop_context, my_data_context, put_index_data,  mydata);
}

static
netsnmp_variable_list*
psychPluginTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychPluginTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->psych_it == context->psych_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const psych::psych_t* psych = *context->psych_it++;

/* psychPluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)psych->plugin_id_.c_str(), psych->plugin_id_.length());
        idx = idx->next_variable;

/* psychPluginInstance */
	const unsigned instance = psych->instance_;
	snmp_set_var_typed_value (idx, ASN_UNSIGNED, (const u_char*)&instance, sizeof (instance));

/* reference remains in list */
        *my_data_context = (void*)psych;
        return put_index_data;
}

static
void
psychPluginTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychPluginTable_free_loop_context ()";

/* delete context and shared lock on global list of all psych objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the psychPluginTable table
 */
static
int
psychPluginTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "psychPluginTable_handler()";

	switch (reqinfo->mode) {

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const psych::psych_t* psych = static_cast<psych::psych_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == psych) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "psychPluginTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {
						
			case COLUMN_PSYCHPLUGINWINDOWSREGISTRYKEY:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)psych->config_.key.c_str(), psych->config_.key.length());
				break;

			case COLUMN_PSYCHPLUGINSERVICENAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)psych->config_.service_name.c_str(), psych->config_.service_name.length());
				break;

			case COLUMN_PSYCHPLUGINMONITORNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)psych->config_.monitor_name.c_str(), psych->config_.monitor_name.length());
				break;

			case COLUMN_PSYCHPLUGINEVENTQUEUENAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)psych->config_.event_queue_name.c_str(), psych->config_.event_queue_name.length());
				break;

			case COLUMN_PSYCHPLUGINVENDORNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)psych->config_.vendor_name.c_str(), psych->config_.vendor_name.length());
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "psychPluginTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "psychPluginTable_handler: unnsupported mode.\n");
		break;
	}
	return SNMP_ERR_NOERROR;
}

/* Initialize the psychPluginPerformanceTable table by defining its contents and how it's structured
*/
static
int
initialize_table_psychPluginPerformanceTable(void)
{
	DLOG(INFO) << "initialize_table_psychPluginPerformanceTable()";

	static const oid psychPluginPerformanceTable_oid[] = {1,3,6,1,4,1,67,2,1,4};
	const size_t psychPluginPerformanceTable_oid_len = OID_LENGTH(psychPluginPerformanceTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"psychPluginPerformanceTable",   psychPluginPerformanceTable_handler,
		psychPluginPerformanceTable_oid, psychPluginPerformanceTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: psychPluginPerformanceId */
					  ASN_UNSIGNED,  /* index: psychPluginPerformanceInstance */
					  0);
	table_info->min_column = COLUMN_PSYCHTCLQUERYRECEIVED;
	table_info->max_column = COLUMN_PSYCHPSYCHCLOCKDRIFT;
    
	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= psychPluginPerformanceTable_get_first_data_point;
	iinfo->get_next_data_point	= psychPluginPerformanceTable_get_next_data_point;
	iinfo->free_loop_context_at_end = psychPluginPerformanceTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work
 */
static
netsnmp_variable_list*
psychPluginPerformanceTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychPluginPerformanceTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (psych::psych_t::global_list_lock_, psych::psych_t::global_list_));
	if (!(bool)context || context->psych_list.empty()) {
		DLOG(INFO) << "No instances";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return psychPluginPerformanceTable_get_next_data_point(my_loop_context, my_data_context, put_index_data, mydata);
}

static
netsnmp_variable_list*
psychPluginPerformanceTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychPluginPerformanceTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->psych_it == context->psych_list.end()) {
		DLOG(INFO) << "End of instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const psych::psych_t* psych = *context->psych_it++;

/* psychPluginPerformanceId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)psych->plugin_id_.c_str(), psych->plugin_id_.length());
        idx = idx->next_variable;

/* psychPluginPerformanceInstance */
	const unsigned instance = psych->instance_;
	snmp_set_var_typed_value (idx, ASN_UNSIGNED, (const u_char*)&instance, sizeof (instance));

/* reference remains in list */
        *my_data_context = (void*)psych;
	return put_index_data;
}

static
void
psychPluginPerformanceTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychPluginPerformanceTable_free_loop_context()";

/* delete context and shared lock on global list of all psych objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the psychPluginPerformanceTable table
 */
static
int
psychPluginPerformanceTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "psychPluginPerformanceTable_handler()";

	switch (reqinfo->mode) {
        
/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const psych::psych_t* psych = static_cast<psych::psych_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == psych) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info  = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "psychPluginPerformanceTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {

			case COLUMN_PSYCHTCLQUERYRECEIVED:
				{
					const unsigned tcl_query_received = psych->cumulative_stats_[PSYCH_PC_TCL_QUERY_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&tcl_query_received, sizeof (tcl_query_received));
				}
				break;

			case COLUMN_PSYCHTIMERQUERYRECEIVED:
				{
					const unsigned timer_query_received = psych->cumulative_stats_[PSYCH_PC_TIMER_QUERY_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&timer_query_received, sizeof (timer_query_received));
				}
				break;

			case COLUMN_PSYCHLASTACTIVITY:
				{
					union {
						uint32_t	uint_value;
						__time32_t	time32_t_value;
					} last_activity;
					last_activity.time32_t_value = (psych->last_activity_ - kUnixEpoch).total_seconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&last_activity.uint_value, sizeof (last_activity.uint_value));
				}
				break;

			case COLUMN_PSYCHTCLSVCTIMEMIN:
				{
/* conversion of 64-bit integer */
					unsigned min_svc_time = 0;
					if (!psych->min_tcl_time_.is_special())
						min_svc_time = (unsigned)psych->min_tcl_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&min_svc_time, sizeof (min_svc_time));
				}
				break;

			case COLUMN_PSYCHTCLSVCTIMEMEAN:
				{
					unsigned mean_svc_time = 0;
					if (psych->cumulative_stats_[PSYCH_PC_TCL_QUERY_RECEIVED] > 0)
						mean_svc_time = (unsigned)(psych->total_tcl_time_.total_milliseconds() / psych->cumulative_stats_[PSYCH_PC_TCL_QUERY_RECEIVED]);
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mean_svc_time, sizeof (mean_svc_time));
				}
				break;

			case COLUMN_PSYCHTCLSVCTIMEMAX:
				{
					unsigned max_svc_time = 0;
					if (!psych->max_tcl_time_.is_special())
						max_svc_time = (unsigned)psych->max_tcl_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&max_svc_time, sizeof (max_svc_time));
				}
				break;

			case COLUMN_PSYCHTIMERSVCTIMEMIN:
				{
/* conversion of 64-bit integer */
					unsigned min_svc_time = 0;
					if (!psych->min_refresh_time_.is_special())
						min_svc_time = (unsigned)psych->min_refresh_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&min_svc_time, sizeof (min_svc_time));
				}
				break;

			case COLUMN_PSYCHTIMERSVCTIMEMEAN:
				{
					unsigned mean_svc_time = 0;
					if (psych->cumulative_stats_[PSYCH_PC_TIMER_QUERY_RECEIVED] > 0)
						mean_svc_time = (unsigned)(psych->total_refresh_time_.total_milliseconds() / psych->cumulative_stats_[PSYCH_PC_TIMER_QUERY_RECEIVED]);
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mean_svc_time, sizeof (mean_svc_time));
				}
				break;

			case COLUMN_PSYCHTIMERSVCTIMEMAX:
				{
					unsigned max_svc_time = 0;
					if (!psych->max_refresh_time_.is_special())
						max_svc_time = (unsigned)psych->max_refresh_time_.total_milliseconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&max_svc_time, sizeof (max_svc_time));
				}
				break;

			case COLUMN_PSYCHMSGSSENT:
				{
					const unsigned msg_sent = (bool)psych->provider_ ? psych->provider_->cumulative_stats_[PROVIDER_PC_MSGS_SENT] : 0;
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&msg_sent, sizeof (msg_sent));
				}
				break;

			case COLUMN_PSYCHLASTMSGSSENT:
				{
					union {
						uint32_t	uint_value;
						__time32_t	time32_t_value;
					} last_activity;
					last_activity.time32_t_value = (bool)psych->provider_ ? ((psych->provider_->last_activity_ - kUnixEpoch).total_seconds()) : 0;
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&last_activity.uint_value, sizeof (last_activity.uint_value));
				}
				break;

			case COLUMN_PSYCHHTTPREQUESTSENT:
				{
					const unsigned http_sent = psych->cumulative_stats_[PSYCH_PC_HTTP_REQUEST_SENT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_sent, sizeof (http_sent));
				}
				break;

			case COLUMN_PSYCHHTTP1XXRECEIVED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_1XX_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTP2XXRECEIVED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_2XX_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTP3XXRECEIVED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_3XX_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTP4XXRECEIVED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_4XX_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTP5XXRECEIVED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_5XX_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTP200RECEIVED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_200_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTP304RECEIVED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_304_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTPMALFORMED:
				{
					const unsigned http_rcvd = psych->cumulative_stats_[PSYCH_PC_HTTP_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&http_rcvd, sizeof (http_rcvd));
				}
				break;

			case COLUMN_PSYCHHTTPRETRIESEXCEEDED:
				{
					const unsigned num_retries = psych->cumulative_stats_[PSYCH_PC_HTTP_RETRIES_EXCEEDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&num_retries, sizeof (num_retries));
				}
				break;

			case COLUMN_PSYCHHTTPDCLOCKDRIFT:
				{
					const unsigned clock_offset = psych->cumulative_stats_[PSYCH_PC_HTTPD_CLOCK_DRIFT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&clock_offset, sizeof (clock_offset));
				}
				break;

			case COLUMN_PSYCHHTTPCLOCKDRIFT:
				{
					const unsigned clock_offset = psych->cumulative_stats_[PSYCH_PC_HTTP_CLOCK_DRIFT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&clock_offset, sizeof (clock_offset));
				}
				break;

			case COLUMN_PSYCHPSYCHCLOCKDRIFT:
				{
					const unsigned clock_offset = psych->cumulative_stats_[PSYCH_PC_PSYCH_CLOCK_DRIFT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&clock_offset, sizeof (clock_offset));
				}
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "psychPluginPerformanceTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "psychPluginPerformanceTable_handler: unsupported mode.\n");
		break;
    }

    return SNMP_ERR_NOERROR;
}

/* Initialize the psychSessionTable table by defining its contents and how it's structured.
 */
static
int
initialize_table_psychSessionTable(void)
{
	DLOG(INFO) << "initialize_table_psychSessionTable()";

	static const oid psychSessionTable_oid[] = {1,3,6,1,4,1,67,2,1,5};
	const size_t psychSessionTable_oid_len = OID_LENGTH (psychSessionTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"psychSessionTable",	psychSessionTable_handler,
		psychSessionTable_oid,	psychSessionTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: psychSessionId */
					  ASN_UNSIGNED,  /* index: psychSessionPluginInstance */
					  ASN_UNSIGNED,  /* index: psychSessionUniqueInstance */
					  0);
	table_info->min_column = COLUMN_PSYCHSESSIONRSSLSERVERS;
	table_info->max_column = COLUMN_PSYCHSESSIONPUBLISHERNAME;
    
	iinfo = SNMP_MALLOC_TYPEDEF (netsnmp_iterator_info);
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= psychSessionTable_get_first_data_point;
	iinfo->get_next_data_point	= psychSessionTable_get_next_data_point;
	iinfo->free_loop_context_at_end	= psychSessionTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
static 
netsnmp_variable_list*
psychSessionTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychSessionTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context. */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (psych::psych_t::global_list_lock_, psych::psych_t::global_list_));
	if (!(bool)context || context->psych_list.empty()) {
		DLOG(INFO) << "No plugin instances.";
		return nullptr;
	}

/* Find first node, through all plugin instances. */
	for (context->psych_it = context->psych_list.begin();
		context->psych_it != context->psych_list.end();
		++(context->psych_it))
	{
/* and through all sessions for each plugin provider. */
		context->session_it = (*context->psych_it)->provider_->sessions_.begin();
		if (context->session_it != (*context->psych_it)->provider_->sessions_.end()) {
			break;
		}
	}

/* no node found. */
	if (context->session_it == (*context->psych_it)->provider_->sessions_.end()) {
		DLOG(INFO) << "No session instances.";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return psychSessionTable_get_next_data_point (my_loop_context, my_data_context, put_index_data,  mydata);
}

static
netsnmp_variable_list*
psychSessionTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychSessionTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->psych_it == context->psych_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}
	if (context->session_it == (*context->psych_it)->provider_->sessions_.end()) {
		DLOG(INFO) << "End of session instances.";
		return nullptr;
	}

/* this session instance as a data point */
	const psych::session_t* session = (*context->session_it).get();
	const psych::psych_t* psych = *context->psych_it;

/* psychSessionPluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)psych->plugin_id_.c_str(), psych->plugin_id_.length());
        idx = idx->next_variable;

/* psychSessionPluginUniqueInstance */
	const unsigned instance = psych->instance_;
	snmp_set_var_typed_value (idx, ASN_UNSIGNED, (const u_char*)&instance, sizeof (instance));
        idx = idx->next_variable;

/* psychSessionUniqueInstance */
	const unsigned session_instance = session->instance_id_;
	snmp_set_var_typed_value (idx, ASN_UNSIGNED, (const u_char*)&session_instance, sizeof (session_instance));

/* hunt for next valid node */
	while (++(context->session_it) == (*context->psych_it)->provider_->sessions_.end()) {
		if (++(context->psych_it) == context->psych_list.end()) {
			break;
		}
		context->session_it = (*context->psych_it)->provider_->sessions_.begin();
	}

/* reference remains in list */
        *my_data_context = (void*)session;
        return put_index_data;
}

static
void
psychSessionTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychSessionTable_free_loop_context ()";

/* delete context and shared lock on global list of all psych objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the psychPluginTable table
 */
static
int
psychSessionTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "psychSessionTable_handler()";

	switch (reqinfo->mode) {

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const psych::session_t* session = static_cast<psych::session_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == session) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "psychSessionTable_handler: empty table request info.\n");
				continue;
			}

			switch (table_info->colnum) {
						
			case COLUMN_PSYCHSESSIONRSSLSERVERS:
			{
				const char *rssl_server = "";
				size_t rssl_server_len = 0;
				if (!session->config_.rssl_servers.empty()) {
					std::ostringstream ss;
					for (auto it = session->config_.rssl_servers.begin();
						it != session->config_.rssl_servers.end();
						++it)
					{
						if (it != session->config_.rssl_servers.begin())
							ss << ", ";
						ss << *it;
					}
					rssl_server     = ss.str().c_str();
					rssl_server_len = ss.str().length();
				}
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)rssl_server, rssl_server_len);
				break;
			}

			case COLUMN_PSYCHSESSIONRSSLDEFAULTPORT:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.rssl_default_port.c_str(), session->config_.rssl_default_port.length());
				break;

			case COLUMN_PSYCHSESSIONAPPLICATIONID:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.application_id.c_str(), session->config_.application_id.length());
				break;

			case COLUMN_PSYCHSESSIONINSTANCEID:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.instance_id.c_str(), session->config_.instance_id.length());
				break;

			case COLUMN_PSYCHSESSIONUSERNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.user_name.c_str(), session->config_.user_name.length());
				break;

			case COLUMN_PSYCHSESSIONPOSITION:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.position.c_str(), session->config_.position.length());
				break;

			case COLUMN_PSYCHSESSIONSESSIONNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.session_name.c_str(), session->config_.session_name.length());
				break;

			case COLUMN_PSYCHSESSIONCONNECTIONNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.connection_name.c_str(), session->config_.connection_name.length());
				break;

			case COLUMN_PSYCHSESSIONPUBLISHERNAME:
				snmp_set_var_typed_value (var, ASN_OCTET_STR,
					(const u_char*)session->config_.publisher_name.c_str(), session->config_.publisher_name.length());
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "psychSessionTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "psychSessionTable_handler: unnsupported mode.\n");
		break;
	}
	return SNMP_ERR_NOERROR;
}

/* Initialize the psychSessionPerformanceTable table by defining its contents and how it's structured
*/
static
int
initialize_table_psychSessionPerformanceTable(void)
{
	DLOG(INFO) << "initialize_table_psychSessionPerformanceTable()";

	static const oid psychSessionPerformanceTable_oid[] = {1,3,6,1,4,1,67,2,1,6};
	const size_t psychSessionPerformanceTable_oid_len = OID_LENGTH(psychSessionPerformanceTable_oid);
	netsnmp_handler_registration* reg = nullptr;
	netsnmp_iterator_info* iinfo = nullptr;
	netsnmp_table_registration_info* table_info = nullptr;

	reg = netsnmp_create_handler_registration (
		"psychSessionPerformanceTable",   psychSessionPerformanceTable_handler,
		psychSessionPerformanceTable_oid, psychSessionPerformanceTable_oid_len,
		HANDLER_CAN_RONLY
		);
	if (nullptr == reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);
	if (nullptr == table_info)
		goto error;
	netsnmp_table_helper_add_indexes (table_info,
					  ASN_OCTET_STR,  /* index: psychSessionPerformancePluginId */
					  ASN_UNSIGNED,  /* index: psychSessionPerformancePluginUniqueInstance */
					  ASN_UNSIGNED,  /* index: psychSessionPerformanceUniqueInstance */
					  0);
	table_info->min_column = COLUMN_PSYCHSESSIONLASTACTIVITY;
	table_info->max_column = COLUMN_PSYCHMMTLOGINDATASTATE;
    
	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (nullptr == iinfo)
		goto error;
	iinfo->get_first_data_point	= psychSessionPerformanceTable_get_first_data_point;
	iinfo->get_next_data_point	= psychSessionPerformanceTable_get_next_data_point;
	iinfo->free_loop_context_at_end = psychSessionPerformanceTable_free_loop_context;
	iinfo->table_reginfo		= table_info;
    
	return netsnmp_register_table_iterator (reg, iinfo);

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var (table_info->indexes);
	SNMP_FREE (table_info);
	SNMP_FREE (iinfo);
	netsnmp_handler_registration_free (reg);
	return -1;
}

/* Example iterator hook routines - using 'get_next' to do most of the work
 */
static
netsnmp_variable_list*
psychSessionPerformanceTable_get_first_data_point (
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata			/* iinfo on init() */
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychSessionerformanceTable_get_first_data_point()";

/* Create our own context for this SNMP loop, lock on list follows lifetime of context */
	std::shared_ptr<snmp_context_t> context (new snmp_context_t (psych::psych_t::global_list_lock_, psych::psych_t::global_list_));
	if (!(bool)context || context->psych_list.empty()) {
		DLOG(INFO) << "No plugin instances";
		return nullptr;
	}

/* Find first node, through all plugin instances. */
	for (context->psych_it = context->psych_list.begin();
		context->psych_it != context->psych_list.end();
		++(context->psych_it))
	{
/* and through all sessions for each plugin provider. */
		context->session_it = (*context->psych_it)->provider_->sessions_.begin();
		if (context->session_it != (*context->psych_it)->provider_->sessions_.end()) {
			break;
		}
	}

/* no node found. */
	if (context->session_it == (*context->psych_it)->provider_->sessions_.end()) {
		DLOG(INFO) << "No session instances.";
		return nullptr;
	}

/* Save context with NET-SNMP iterator. */
	*my_loop_context = context.get();
	snmp_context_t::global_list.push_back (std::move (context));

/* pass on for generic row access */
	return psychSessionPerformanceTable_get_next_data_point(my_loop_context, my_data_context, put_index_data, mydata);
}

static
netsnmp_variable_list*
psychSessionPerformanceTable_get_next_data_point (
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != my_data_context);
	assert (nullptr != put_index_data);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychSessionPerformanceTable_get_next_data_point()";

	snmp_context_t* context = static_cast<snmp_context_t*>(*my_loop_context);
	netsnmp_variable_list *idx = put_index_data;

/* end of data points */
	if (context->psych_it == context->psych_list.end()) {
		DLOG(INFO) << "End of plugin instances.";
		return nullptr;
	}
	if (context->session_it == (*context->psych_it)->provider_->sessions_.end()) {
		DLOG(INFO) << "End of session instances.";
		return nullptr;
	}

/* this plugin instance as a data point */
	const psych::session_t* session = (*context->session_it).get();
	const psych::psych_t* psych = *context->psych_it;

/* psychSessionPerformancePluginId */
	snmp_set_var_typed_value (idx, ASN_OCTET_STR, (const u_char*)psych->plugin_id_.c_str(), psych->plugin_id_.length());
        idx = idx->next_variable;

/* psychSessionPerformancePluginUniqueInstance */
	const unsigned instance = psych->instance_;
	snmp_set_var_typed_value (idx, ASN_UNSIGNED, (const u_char*)&instance, sizeof (instance));
        idx = idx->next_variable;

/* psychSessionPerformanceUniqueInstance */
	const unsigned session_instance = session->instance_id_;
	snmp_set_var_typed_value (idx, ASN_UNSIGNED, (const u_char*)&session_instance, sizeof (session_instance));

/* hunt for next valid node */
	while (++(context->session_it) == (*context->psych_it)->provider_->sessions_.end()) {
		if (++(context->psych_it) == context->psych_list.end()) {
			break;
		}
		context->session_it = (*context->psych_it)->provider_->sessions_.begin();
	}

/* reference remains in list */
        *my_data_context = (void*)session;
	return put_index_data;
}

static
void
psychSessionPerformanceTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata
	)
{
	assert (nullptr != my_loop_context);
	assert (nullptr != mydata);

	DLOG(INFO) << "psychSessionPerformanceTable_free_loop_context()";

/* delete context and shared lock on global list of all psych objects */
	snmp_context_t* context = static_cast<snmp_context_t*>(my_loop_context);
/* I'm sure there must be a better method :-( */
	snmp_context_t::global_list.erase (std::remove_if (snmp_context_t::global_list.begin(),
		snmp_context_t::global_list.end(),
		[context](std::shared_ptr<snmp_context_t>& shared_context) -> bool {
			return shared_context.get() == context;
	}));
}

/* handles requests for the psychSessionPerformanceTable table
 */
static
int
psychSessionPerformanceTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests
	)
{
	assert (nullptr != handler);
	assert (nullptr != reginfo);
	assert (nullptr != reqinfo);
	assert (nullptr != requests);

	DLOG(INFO) << "psychSessionPerformanceTable_handler()";

	switch (reqinfo->mode) {
        
/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request = requests;
		     request;
		     request = request->next)
		{
			const psych::session_t* session = static_cast<psych::session_t*>(netsnmp_extract_iterator_context (request));
			if (nullptr == session) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list* var = request->requestvb;
			netsnmp_table_request_info* table_info  = netsnmp_extract_table_info (request);
			if (nullptr == table_info) {
				snmp_log (__netsnmp_LOG_ERR, "psychSessionPerformanceTable_handler: empty table request info.\n");
				continue;
			}
    
			switch (table_info->colnum) {

			case COLUMN_PSYCHSESSIONLASTACTIVITY:
				{
					union {
						uint32_t	uint_value;
						__time32_t	time32_t_value;
					} last_activity;
					last_activity.time32_t_value = (session->last_activity_ - kUnixEpoch).total_seconds();
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&last_activity.uint_value, sizeof (last_activity.uint_value));
				}
				break;

			case COLUMN_PSYCHSESSIONRFAMSGSSENT:
				{
					const unsigned rfa_msg_sent = session->cumulative_stats_[SESSION_PC_RFA_MSGS_SENT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&rfa_msg_sent, sizeof (rfa_msg_sent));
				}
				break;

			case COLUMN_PSYCHRFAEVENTSRECEIVED:
				{
					const unsigned rfa_events_received = session->cumulative_stats_[SESSION_PC_RFA_EVENTS_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&rfa_events_received, sizeof (rfa_events_received));
				}
				break;

			case COLUMN_PSYCHRFAEVENTSDISCARDED:
				{
					const unsigned rfa_events_discarded = session->cumulative_stats_[SESSION_PC_RFA_EVENTS_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&rfa_events_discarded, sizeof (rfa_events_discarded));
				}
				break;
            
			case COLUMN_PSYCHOMMITEMEVENTSRECEIVED:
				{
					const unsigned omm_item_events_received = session->cumulative_stats_[SESSION_PC_OMM_ITEM_EVENTS_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&omm_item_events_received, sizeof (omm_item_events_received));
				}
				break;

			case COLUMN_PSYCHOMMITEMEVENTSDISCARDED:
				{
					const unsigned omm_item_events_discarded = session->cumulative_stats_[SESSION_PC_OMM_ITEM_EVENTS_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&omm_item_events_discarded, sizeof (omm_item_events_discarded));
				}
				break;

			case COLUMN_PSYCHRESPONSEMSGSRECEIVED:
				{
					const unsigned response_msgs_received = session->cumulative_stats_[SESSION_PC_RESPONSE_MSGS_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&response_msgs_received, sizeof (response_msgs_received));
				}
				break;

			case COLUMN_PSYCHRESPONSEMSGSDISCARDED:
				{
					const unsigned response_msgs_discarded = session->cumulative_stats_[SESSION_PC_RESPONSE_MSGS_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&response_msgs_discarded, sizeof (response_msgs_discarded));
				}
				break;

			case COLUMN_PSYCHMMTLOGINRESPONSERECEIVED:
				{
					const unsigned mmt_login_responses_received = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_RESPONSE_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_login_responses_received, sizeof (mmt_login_responses_received));
				}
				break;

			case COLUMN_PSYCHMMTLOGINRESPONSEDISCARDED:
				{
					const unsigned mmt_login_responses_discarded = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_RESPONSE_DISCARDED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_login_responses_discarded, sizeof (mmt_login_responses_discarded));
				}
				break;

			case COLUMN_PSYCHMMTLOGINSUCCESSRECEIVED:
				{
					const unsigned mmt_login_success_received = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_SUCCESS_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_login_success_received, sizeof (mmt_login_success_received));
				}
				break;

			case COLUMN_PSYCHMMTLOGINSUSPECTRECEIVED:
				{
					const unsigned mmt_login_suspect_received = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_SUSPECT_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_login_suspect_received, sizeof (mmt_login_suspect_received));
				}
				break;

			case COLUMN_PSYCHMMTLOGINCLOSEDRECEIVED:
				{
					const unsigned mmt_login_closed_received = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_CLOSED_RECEIVED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_login_closed_received, sizeof (mmt_login_closed_received));
				}
				break;

			case COLUMN_PSYCHOMMCMDERRORS:
				{
					const unsigned omm_cmd_errors = session->cumulative_stats_[SESSION_PC_OMM_CMD_ERRORS];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&omm_cmd_errors, sizeof (omm_cmd_errors));
				}
				break;

			case COLUMN_PSYCHMMTLOGINSVALIDATED:
				{
					const unsigned mmt_logins_validated = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_logins_validated, sizeof (mmt_logins_validated));
				}
				break;

			case COLUMN_PSYCHMMTLOGINSMALFORMED:
				{
					const unsigned mmt_logins_malformed = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_logins_malformed, sizeof (mmt_logins_malformed));
				}
				break;

			case COLUMN_PSYCHMMTLOGINSSENT:
				{
					const unsigned mmt_logins_sent = session->cumulative_stats_[SESSION_PC_MMT_LOGIN_SENT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_logins_sent, sizeof (mmt_logins_sent));
				}
				break;

			case COLUMN_PSYCHMMTDIRECTORYSVALIDATED:
				{
					const unsigned mmt_directorys_validated = session->cumulative_stats_[SESSION_PC_MMT_DIRECTORY_VALIDATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_directorys_validated, sizeof (mmt_directorys_validated));
				}
				break;

			case COLUMN_PSYCHMMTDIRECTORYSMALFORMED:
				{
					const unsigned mmt_directorys_malformed = session->cumulative_stats_[SESSION_PC_MMT_DIRECTORY_MALFORMED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_directorys_malformed, sizeof (mmt_directorys_malformed));
				}
				break;

			case COLUMN_PSYCHMMTDIRECTORYSSENT:
				{
					const unsigned mmt_directorys_sent = session->cumulative_stats_[SESSION_PC_MMT_DIRECTORY_SENT];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&mmt_directorys_sent, sizeof (mmt_directorys_sent));
				}
				break;

			case COLUMN_PSYCHTOKENSGENERATED:
				{
					const unsigned tokens_generated = session->cumulative_stats_[SESSION_PC_TOKENS_GENERATED];
					snmp_set_var_typed_value (var, ASN_COUNTER, /* ASN_COUNTER32 */
						(const u_char*)&tokens_generated, sizeof (tokens_generated));
				}
				break;

			case COLUMN_PSYCHMMTLOGINSTREAMSTATE:
				{
/* 0 = rfa::common::RespStatus::UnspecifiedEnum */
					const int stream_state = session->stream_state_;
					snmp_set_var_typed_value (var, ASN_INTEGER,
						(const u_char*)&stream_state, sizeof (stream_state));
				}
				break;

			case COLUMN_PSYCHMMTLOGINDATASTATE:
				{
/* 0 = rfa::common::RespStatus::UnspecifiedStreamStateEnum */
					const int data_state = session->data_state_;
					snmp_set_var_typed_value (var, ASN_INTEGER,
						(const u_char*)&data_state, sizeof (data_state));
				}
				break;

			default:
				snmp_log (__netsnmp_LOG_ERR, "psychSessionPerformanceTable_handler: unknown column.\n");
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHOBJECT);
				break;
			}
		}
		break;

	default:
		snmp_log (__netsnmp_LOG_ERR, "psychSessionPerformanceTable_handler: unsupported mode.\n");
		break;
    }

    return SNMP_ERR_NOERROR;
}

} /* namespace psych */

/* eof */
